#!/usr/bin/env python3
"""
Firmware Download Script f√ºr IWR6843AOP
L√§dt Firmware von GitHub und bereitet sie f√ºr ESPHome vor
"""

import os
import sys
import requests
import hashlib
from pathlib import Path

# Konfiguration
FIRMWARE_URLS = {
    "vital_signs": "https://raw.githubusercontent.com/YOUR_USERNAME/YOUR_REPO/main/firmware/vital_signs_tracking_6843AOP_demo.bin",
    # Weitere Firmware-Dateien hier hinzuf√ºgen
}

FIRMWARE_DIR = Path("firmware")
FIRMWARE_DIR.mkdir(exist_ok=True)

def download_file(url, destination):
    """Download file from URL"""
    print(f"üì• Downloading from: {url}")
    print(f"üìÅ Destination: {destination}")
    
    try:
        response = requests.get(url, stream=True, timeout=30)
        response.raise_for_status()
        
        total_size = int(response.headers.get('content-length', 0))
        downloaded = 0
        
        with open(destination, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192):
                if chunk:
                    f.write(chunk)
                    downloaded += len(chunk)
                    if total_size > 0:
                        progress = (downloaded / total_size) * 100
                        print(f"\r‚è≥ Progress: {progress:.1f}% ({downloaded}/{total_size} bytes)", end='')
        
        print(f"\n‚úÖ Download complete: {destination}")
        return True
        
    except requests.exceptions.RequestException as e:
        print(f"\n‚ùå Download failed: {e}")
        return False

def calculate_sha256(file_path):
    """Calculate SHA256 hash of file"""
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()

def verify_firmware(file_path):
    """Verify firmware file integrity"""
    if not os.path.exists(file_path):
        print(f"‚ùå File not found: {file_path}")
        return False
    
    file_size = os.path.getsize(file_path)
    print(f"üìä File size: {file_size} bytes ({file_size/1024:.1f} KB)")
    
    if file_size < 1024:
        print("‚ö†Ô∏è  Warning: File seems too small")
        return False
    
    # Check magic header for IWR6843 firmware (0x5254534D = "MSTR" in little-endian)
    with open(file_path, 'rb') as f:
        header = f.read(4)
        header_hex = header.hex()
        print(f"üîç File header: 0x{header_hex}")
        
        # IWR68xx uses META_IMAGE format with header 0x5254534D
        if header_hex in ['4d535452', '5254534d']:  # Both endianness
            print("‚úÖ Valid IWR68xx firmware header detected")
            return True
        else:
            print(f"‚ö†Ô∏è  Unexpected header (expected 0x5254534D, got 0x{header_hex})")
            print("   Firmware might still be valid for older formats")
            return True  # Don't fail, just warn
    
    return True

def generate_esphome_config(firmware_files):
    """Generate ESPHome configuration snippet"""
    config_snippet = """
# ============================================
# Firmware Files Configuration
# Generated by download_firmware.py
# ============================================

# Embed firmware files at compile time
# These files will be included in the ESP32 flash
"""
    
    for name, file_path in firmware_files.items():
        if os.path.exists(file_path):
            sha256 = calculate_sha256(file_path)
            size = os.path.getsize(file_path)
            
            config_snippet += f"""
# {name} Firmware
# Size: {size} bytes ({size/1024:.1f} KB)
# SHA256: {sha256}
"""
    
    config_file = Path("firmware_config_generated.yaml")
    with open(config_file, 'w') as f:
        f.write(config_snippet)
    
    print(f"\nüìù Generated config: {config_file}")

def main():
    """Main function"""
    print("=" * 60)
    print("üéØ IWR6843AOP Firmware Download Tool")
    print("=" * 60)
    
    if len(sys.argv) > 1:
        # Custom URL provided
        custom_url = sys.argv[1]
        custom_name = Path(custom_url).name
        destination = FIRMWARE_DIR / custom_name
        
        if download_file(custom_url, destination):
            if verify_firmware(destination):
                sha256 = calculate_sha256(destination)
                print(f"\nüîê SHA256: {sha256}")
                print(f"\n‚úÖ SUCCESS: Firmware ready at {destination}")
                return 0
            else:
                print(f"\n‚ö†Ô∏è  Warning: Firmware verification failed")
                return 1
        else:
            print(f"\n‚ùå FAILED: Could not download firmware")
            return 1
    
    # Download all configured firmwares
    success_count = 0
    firmware_files = {}
    
    for name, url in FIRMWARE_URLS.items():
        print(f"\nüì¶ Processing: {name}")
        destination = FIRMWARE_DIR / f"{name}.bin"
        
        if download_file(url, destination):
            if verify_firmware(destination):
                sha256 = calculate_sha256(destination)
                print(f"üîê SHA256: {sha256}")
                firmware_files[name] = destination
                success_count += 1
            else:
                print(f"‚ö†Ô∏è  Verification failed for {name}")
        else:
            print(f"‚ùå Download failed for {name}")
    
    # Generate config
    if firmware_files:
        generate_esphome_config(firmware_files)
    
    print("\n" + "=" * 60)
    print(f"üìä Summary: {success_count}/{len(FIRMWARE_URLS)} firmware files downloaded")
    print("=" * 60)
    
    if success_count == len(FIRMWARE_URLS):
        print("\n‚úÖ All firmware files ready!")
        print("\nüí° Next steps:")
        print("   1. Review firmware_config_generated.yaml")
        print("   2. Update iwr6843_with_flash.yaml with firmware paths")
        print("   3. Compile and upload ESPHome")
        return 0
    else:
        print("\n‚ö†Ô∏è  Some firmware files failed to download")
        return 1

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Fatal error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

